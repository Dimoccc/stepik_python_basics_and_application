# Вам дано описание наследования классов исключений в следующем формате.
# <имя исключения 1> : <имя исключения 2> <имя исключения 3> ... <имя исключения k>
# Это означает, что исключение 1 наследуется от исключения 2, исключения 3, и т. д.

# Или эквивалентно записи:
# class Error1(Error2, Error3 ... ErrorK):
#     pass

# Антон написал код, который выглядит следующим образом.

# try:
#    foo()
# except <имя 1>:
#    print("<имя 1>")
# except <имя 2>:
#    print("<имя 2>")
# ...
# Костя посмотрел на этот код и указал Антону на то, что некоторые исключения можно не ловить, так как ранее в коде будет пойман их предок. Но Антон не помнит какие исключения наследуются от каких. Помогите ему выйти из неловкого положения и напишите программу, которая будет определять обработку каких исключений можно удалить из кода.

# Важное примечание:
# В отличие от предыдущей задачи, типы исключений не созданы.
# Создавать классы исключений также не требуется
# Мы просим вас промоделировать этот процесс, и понять какие из исключений можно и не ловить, потому что мы уже ранее где-то поймали их предка.

# put your python code here

n = int(input())
classes = {}
for i in range(n):
    line = input()
    parts = line.split(" : ")
    cls = parts[0]
    if len(parts) == 1:
        classes[cls] = []
    else:
        classes[cls] = parts[1].split(" ")


def check(src, dest):
    if src == dest:
        return True
    return any([check(child, dest) for child in classes[src]])


m = int(input())
used = []

for i in range(m):
    cls = input()
    if any([check(cls, used_one) for used_one in used]):
        print(cls)
    used.append(cls)


